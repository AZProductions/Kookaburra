# **Index API**
You can use the index api in many ways, we use it to update Kookaburra to the newest version.
Here is an example response:
```json
[
  {
    "url_win64": "https://github.com/AZProductions/Kookaburra/releases/download/0.8.5/KookaburraShell_win-x64_0.8.5.exe",
    "url_win86": "https://github.com/AZProductions/Kookaburra/releases/download/0.8.5/KookaburraShell_win-x86_0.8.5.exe",
    "url_winarm": "https://github.com/AZProductions/Kookaburra/releases/download/0.8.5/KookaburraShell_win-arm_0.8.5.exe",
    "url_linux": "https://github.com/AZProductions/Kookaburra/releases/download/0.8.5/KookaburraShell_linux_0.8.5",
    "url_linuxarm": "https://github.com/AZProductions/Kookaburra/releases/download/0.8.5/KookaburraShell_linux-arm_0.8.5",
    "version": "0.8.5",
    "date": "7/9/21"
  }
]

```

## Code Snippets
#### **C#**
```c#
// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using GetDownloadVersion;
//
//    var newestVersion = NewestVersion.FromJson(jsonString);

namespace GetDownloadVersion
{
    using System;
    using System.Collections.Generic;

    using System.Globalization;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;

    public partial class NewestVersion
    {
        [JsonProperty("url_win64")]
        public object UrlWin64 { get; set; }

        [JsonProperty("url_win86")]
        public object UrlWin86 { get; set; }

        [JsonProperty("url_winarm")]
        public object UrlWinarm { get; set; }

        [JsonProperty("url_linux")]
        public object UrlLinux { get; set; }

        [JsonProperty("url_linuxarm")]
        public object UrlLinuxarm { get; set; }

        [JsonProperty("version")]
        public string Version { get; set; }

        [JsonProperty("date")]
        public string Date { get; set; }
    }

    public partial class NewestVersion
    {
        public static NewestVersion[] FromJson(string json)
        {
            return JsonConvert.DeserializeObject<NewestVersion[]>(json, GetDownloadVersion.Converter.Settings);
        }
    }

    public static class Serialize
    {
        public static string ToJson(this NewestVersion[] self)
        {
            return JsonConvert.SerializeObject(self, GetDownloadVersion.Converter.Settings);
        }
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }
}
```
#### **Go**
```go
// This file was generated from JSON Schema using quicktype, do not modify it directly.
// To parse and unparse this JSON data, add this code to your project and do:
//
//    newestVersion, err := UnmarshalNewestVersion(bytes)
//    bytes, err = newestVersion.Marshal()

package main

import "encoding/json"

type NewestVersion []NewestVersionElement

func UnmarshalNewestVersion(data []byte) (NewestVersion, error) {
	var r NewestVersion
	err := json.Unmarshal(data, &r)
	return r, err
}

func (r *NewestVersion) Marshal() ([]byte, error) {
	return json.Marshal(r)
}

type NewestVersionElement struct {
	URLWin64    interface{} `json:"url_win64"`   
	URLWin86    interface{} `json:"url_win86"`   
	URLWinarm   interface{} `json:"url_winarm"`  
	URLLinux    interface{} `json:"url_linux"`   
	URLLinuxarm interface{} `json:"url_linuxarm"`
	Version     string      `json:"version"`     
	Date        string      `json:"date"`        
}
```
#### **Python (3.6)**
```python
# To use this code, make sure you
#
#     import json
#
# and then, to convert JSON from a string, do
#
#     result = newest_version_from_dict(json.loads(json_string))

from typing import Any, List, TypeVar, Callable, Type, cast


T = TypeVar("T")


def from_none(x: Any) -> Any:
    assert x is None
    return x


def from_str(x: Any) -> str:
    assert isinstance(x, str)
    return x


def from_list(f: Callable[[Any], T], x: Any) -> List[T]:
    assert isinstance(x, list)
    return [f(y) for y in x]


def to_class(c: Type[T], x: Any) -> dict:
    assert isinstance(x, c)
    return cast(Any, x).to_dict()


class NewestVersionElement:
    url_win64: None
    url_win86: None
    url_winarm: None
    url_linux: None
    url_linuxarm: None
    version: str
    date: str

    def __init__(self, url_win64: None, url_win86: None, url_winarm: None, url_linux: None, url_linuxarm: None, version: str, date: str) -> None:
        self.url_win64 = url_win64
        self.url_win86 = url_win86
        self.url_winarm = url_winarm
        self.url_linux = url_linux
        self.url_linuxarm = url_linuxarm
        self.version = version
        self.date = date

    @staticmethod
    def from_dict(obj: Any) -> 'NewestVersionElement':
        assert isinstance(obj, dict)
        url_win64 = from_none(obj.get("url_win64"))
        url_win86 = from_none(obj.get("url_win86"))
        url_winarm = from_none(obj.get("url_winarm"))
        url_linux = from_none(obj.get("url_linux"))
        url_linuxarm = from_none(obj.get("url_linuxarm"))
        version = from_str(obj.get("version"))
        date = from_str(obj.get("date"))
        return NewestVersionElement(url_win64, url_win86, url_winarm, url_linux, url_linuxarm, version, date)

    def to_dict(self) -> dict:
        result: dict = {}
        result["url_win64"] = from_none(self.url_win64)
        result["url_win86"] = from_none(self.url_win86)
        result["url_winarm"] = from_none(self.url_winarm)
        result["url_linux"] = from_none(self.url_linux)
        result["url_linuxarm"] = from_none(self.url_linuxarm)
        result["version"] = from_str(self.version)
        result["date"] = from_str(self.date)
        return result


def newest_version_from_dict(s: Any) -> List[NewestVersionElement]:
    return from_list(NewestVersionElement.from_dict, s)


def newest_version_to_dict(x: List[NewestVersionElement]) -> Any:
    return from_list(lambda x: to_class(NewestVersionElement, x), x)
```
#### **Typescript**
```typescript
// To parse this data:
//
//   import { Convert } from "./file";
//
//   const newestVersion = Convert.toNewestVersion(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

export interface NewestVersion {
    url_win64:    null;
    url_win86:    null;
    url_winarm:   null;
    url_linux:    null;
    url_linuxarm: null;
    version:      string;
    date:         string;
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
    public static toNewestVersion(json: string): NewestVersion[] {
        return cast(JSON.parse(json), a(r("NewestVersion")));
    }

    public static newestVersionToJson(value: NewestVersion[]): string {
        return JSON.stringify(uncast(value, a(r("NewestVersion"))), null, 2);
    }
}

function invalidValue(typ: any, val: any, key: any = ''): never {
    if (key) {
        throw Error(`Invalid value for key "${key}". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
    }
    throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`, );
}

function jsonToJSProps(typ: any): any {
    if (typ.jsonToJS === undefined) {
        const map: any = {};
        typ.props.forEach((p: any) => map[p.json] = { key: p.js, typ: p.typ });
        typ.jsonToJS = map;
    }
    return typ.jsonToJS;
}

function jsToJSONProps(typ: any): any {
    if (typ.jsToJSON === undefined) {
        const map: any = {};
        typ.props.forEach((p: any) => map[p.js] = { key: p.json, typ: p.typ });
        typ.jsToJSON = map;
    }
    return typ.jsToJSON;
}

function transform(val: any, typ: any, getProps: any, key: any = ''): any {
    function transformPrimitive(typ: string, val: any): any {
        if (typeof typ === typeof val) return val;
        return invalidValue(typ, val, key);
    }

    function transformUnion(typs: any[], val: any): any {
        // val must validate against one typ in typs
        const l = typs.length;
        for (let i = 0; i < l; i++) {
            const typ = typs[i];
            try {
                return transform(val, typ, getProps);
            } catch (_) {}
        }
        return invalidValue(typs, val);
    }

    function transformEnum(cases: string[], val: any): any {
        if (cases.indexOf(val) !== -1) return val;
        return invalidValue(cases, val);
    }

    function transformArray(typ: any, val: any): any {
        // val must be an array with no invalid elements
        if (!Array.isArray(val)) return invalidValue("array", val);
        return val.map(el => transform(el, typ, getProps));
    }

    function transformDate(val: any): any {
        if (val === null) {
            return null;
        }
        const d = new Date(val);
        if (isNaN(d.valueOf())) {
            return invalidValue("Date", val);
        }
        return d;
    }

    function transformObject(props: { [k: string]: any }, additional: any, val: any): any {
        if (val === null || typeof val !== "object" || Array.isArray(val)) {
            return invalidValue("object", val);
        }
        const result: any = {};
        Object.getOwnPropertyNames(props).forEach(key => {
            const prop = props[key];
            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
            result[prop.key] = transform(v, prop.typ, getProps, prop.key);
        });
        Object.getOwnPropertyNames(val).forEach(key => {
            if (!Object.prototype.hasOwnProperty.call(props, key)) {
                result[key] = transform(val[key], additional, getProps, key);
            }
        });
        return result;
    }

    if (typ === "any") return val;
    if (typ === null) {
        if (val === null) return val;
        return invalidValue(typ, val);
    }
    if (typ === false) return invalidValue(typ, val);
    while (typeof typ === "object" && typ.ref !== undefined) {
        typ = typeMap[typ.ref];
    }
    if (Array.isArray(typ)) return transformEnum(typ, val);
    if (typeof typ === "object") {
        return typ.hasOwnProperty("unionMembers") ? transformUnion(typ.unionMembers, val)
            : typ.hasOwnProperty("arrayItems")    ? transformArray(typ.arrayItems, val)
            : typ.hasOwnProperty("props")         ? transformObject(getProps(typ), typ.additional, val)
            : invalidValue(typ, val);
    }
    // Numbers can be parsed by Date but shouldn't be.
    if (typ === Date && typeof val !== "number") return transformDate(val);
    return transformPrimitive(typ, val);
}

function cast<T>(val: any, typ: any): T {
    return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val: T, typ: any): any {
    return transform(val, typ, jsToJSONProps);
}

function a(typ: any) {
    return { arrayItems: typ };
}

function u(...typs: any[]) {
    return { unionMembers: typs };
}

function o(props: any[], additional: any) {
    return { props, additional };
}

function m(additional: any) {
    return { props: [], additional };
}

function r(name: string) {
    return { ref: name };
}

const typeMap: any = {
    "NewestVersion": o([
        { json: "url_win64", js: "url_win64", typ: null },
        { json: "url_win86", js: "url_win86", typ: null },
        { json: "url_winarm", js: "url_winarm", typ: null },
        { json: "url_linux", js: "url_linux", typ: null },
        { json: "url_linuxarm", js: "url_linuxarm", typ: null },
        { json: "version", js: "version", typ: "" },
        { json: "date", js: "date", typ: "" },
    ], false),
};

```